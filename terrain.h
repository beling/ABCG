// Class automatically generated by Dev-C++ New Class wizard

#ifndef TERRAIN_H
#define TERRAIN_H

#include <vector>
#include <cmath>
#include <GL/gl.h>     // The GL Header File

#include "libs/geometry.h"
#include "libs/camera2d.h"
#include <iostream>

#include "libs/vec2d.h"

/**
 * Pod³o¿e jest opisane za pomoc¹ ci¹gu wysokoœci odleg³ych o pewien krok (step), 
 * wsp. kolejnych punktów to:
 * ..., (-step, 0.0), (0.0, heights[0]), (step, heights[1]), ..., (n*step, heights[n]), ((n+1)*step, 0.0), ...
 * gdzie n = heights.size - 1
 */
class Terrain
{
		///najni¿szy punkt terenu
		double _lowest;
	
	public:
		
		double lowest() { return _lowest; }
	
	    ///szerokoœæ jednego segmentu
	    double step;
	    
	    ///wysokoœci dla kolejnych punktów
	    std::vector<double> heights;
	    
	    ///pobiera wysokoœæ wierzcho³ka
	    const double operator[](unsigned index) const {
	       return (index >= heights.size()) ? 0.0 : heights[index];
	    }
	    
	    ///sprawdza czy dany punkt dotyka ziemi (lub jest w niej)
	    bool touch(const double& x, const double& y) const;
	    
	    bool touch(const vec2d<double>& p) const {
	    	return touch(p.x, p.y);
	    }
	    
	    /**
          Koryguje po³o¿enie punktu do najbli¿szego punktu na planszy
          @return true jeœli punkt zosta³ przesuniêty (kolidowa³)
        */
	    bool correctPoint(double& x, double& y) const {
           int i = (int)floor(x / step);
           double x0(step * i), y0((*this)[i]), y1((*this)[i+1]);
           double deltay(y1 - y0);
           //sprawdzamy czy punkt ma dobre po³o¿enie
	       //warunek po || by wystarczy³ ale war. z && odrzuca wiêkszoœæ przypadków
	       if ((y > y0 && y > y1) || isOverOn(x, y, x0, y0, step, deltay))
               return false; 
           //nast¹pi³a kolizja, przesówamy pnunkt w najbli¿sze dozwolone wspó³¿êdne
           //to nie dzia³a za szybko wiêc miejmy nadzieje ¿e wyst¹pi ¿adko: 
           double q = getPropNorm(x, y, x0, y0, step, deltay);
           x0 += q * step;          //potencjalne nowe wspó³rzêdne
           y0 += q * deltay;
           //double dist = hypot(x - x0, y - y0);//sqrt(sqr(x - x0) + sqr(y - y0));
           
           x = x0;  //TODO: sprawdziæ odcinki oddalone nie dalej ni¿ dist
           y = y0;
           
           return true;      
	    }
	    
	    bool correctPoint(vec2d<double>& p) const {
	    	return correctPoint(p.x, p.y);
	    }
	
		// class constructor
		Terrain(double step = 1.0)
        : step(step) {};
		// class destructor
		~Terrain();
		
		/**
         rezerwuje teren tak by d³ugoœæ wynosi³a conajmniej minLen
		 nowy kawa³ek terenu ma wysokoœæ height
		*/
		void reserve(unsigned minLen, double height = 0.0) {
		  if (minLen > heights.size()) heights.resize(minLen, height);
		}
		
		/**
         dr¹¿y dó³/górke o g³êbokoœci/wysokoœci |height| i d³ugoœci steps odcinków od start
         (na polach start, start+1, ..., start + steps)
         aproksymuje parabol¹, skrajne punkty pozostaj¹ nie zmienione
         @param height g³êbokoœæ do³u (ujemna dla wg³êbieñ)
         @param start punkt od którego powinien siê zaczynaæ dó³
         @param steps iloœæ odcinków jakie nale¿y zmieniæ
        */ 
		//void createHole(double height, unsigned start, unsigned steps);
		
		/**
		 dr¹¿y dó³ w oparciu o krzyw¹ Bezier'a 3 stopnia
		*/
		//void createHole(double height1, double height2, unsigned start, unsigned steps);
		
		///Rysuje teren
		void draw(const Camera2d& c);
		
		///@return gdzie sie zaczyna wg³êbienie
		double fromX() {
		  return -step;
		}
		
		///@return gdzie sie koñczy wg³êbienie
		double toX() {
		  return heights.size() * step;
		}
		
		///Wczytuje teren ze strumienia. Krok, iloœæ wysokoœci i kolejne wysokoœci.
        friend std::istream &operator>>(std::istream& in, Terrain &t);
        
        ///Zapisuje teren do strumienia. Krok, iloœæ wysokoœci i kolejne wysokoœci.
        friend std::ostream& operator<<(std::ostream& out, Terrain &t);
		
};

#endif // TERRAIN_H

