// Class automatically generated by Dev-C++ New Class wizard

#include "world.h" // class's header file
#include <algorithm>
#include <functional>

World::World()
:   train(/*dt*V=*/ timeStep * 120.0 /*km/h*/ * 1000.0 / 3600.0 /*->m/s*/, 3.0, -100.0, 0.0, 22.0, 8.0, 100000.0, 30000.0) {
    train.addWagon(20.0, 6.0, 50000.0, 30000.0);
    train.addWagon(20.0, 6.0, 50000.0, 30000.0);
	//dump
	terrain.step = 20.0;
	terrain.heights.push_back(-23.0);
	terrain.heights.push_back(-51.0);
	terrain.heights.push_back(-65.0);
	terrain.heights.push_back(-60.0);
	terrain.heights.push_back(-63.0);
	terrain.heights.push_back(-60.0);
	terrain.heights.push_back(-61.0);
	terrain.heights.push_back(-54.0);
	terrain.heights.push_back(-44.0);

	money_limit = 20000.0;

	stop();
}

World::~World() {}

void World::draw_sky(const Camera2d& c) {
    glBegin(GL_QUADS);
    	const double l = c.realLeft(), r = c.realRight();
    	glColor3f(0.4f, 0.67f, 0.96f);
    	glVertex2d(l, 300);
    	glVertex2d(r, 300);
    	glColor3f(0.87f, 0.77f, 0.6f);
    	glVertex2d(r, 0);
    	glVertex2d(l, 0);

    	glColor3f(0.4f, 0.67f, 0.96f);
    	glVertex2d(r, - 300);
    	glVertex2d(l, - 300);
    	glColor3f(0.87f, 0.77f, 0.6f);
    	glVertex2d(l, 0);
    	glVertex2d(r, 0);
    glEnd();
}

void World::draw_water(const Camera2d& c) {
    //draw water:
	double b = c.realBottom();
    if (b > water_y - 0.5) return;
    const double l = c.realLeft(), r = c.realRight();
    b -= 1.0;
    glColor4f(0.1f, 0.3f, 1.0f, 0.2f);
    glBegin(GL_POLYGON);
    	//const double l = c.realLeft(), r = c.realRight();
    	glVertex2d(l, b);

    	const int framents_num = 30;
    	const double fraglen = ((c.realRight() - c.realLeft()) / framents_num);
    	for (int i = 0; i <= framents_num; ++i) {
    		double where = l + fraglen * i;
    		glVertex2d(where, sin(where + time) / 2.0 + /*sin(where + time * 5.0 + 0.3) +*/ water_y);
    	}
    	glVertex2d(r, b);
    glEnd();
}

void World::draw(const Camera2d& c) {
	draw_sky(c);
	train.draw();
//	for (std::list<Link>::iterator i = bridge.begin(); i != bridge.end(); i++)
//	   i->draw();
	for (std::list<Link>::iterator i = links.begin(); i != links.end(); i++)
	   i->draw();
	glColor4f(0.8f, 0.5f, 0.5f, 1.0f);
	for (std::list<Node>::iterator i = nodes.begin(); i != nodes.end(); i++)
       i->draw();
    glColor3f(0.7f, 0.2f, 0.3f);
	for (std::list<Node*>::iterator i = unactive_nodes.begin(); i != unactive_nodes.end(); i++)
       (*i)->draw();
	draw_water(c);
	terrain.draw(c);
}

void World::go() {
    time += timeStep;
    //for (std::list<Node>::iterator i = nodes.begin(); i != nodes.end(); i++)
    //    i->forceX = i->forceY = 0.0;        //zeruje si³y
	for (std::list<Link>::iterator i = links.begin(); i != links.end(); i++)
        i->calcForces();                    //dodaje si³y od belek
    for (std::list<Node>::iterator i = nodes.begin(); i != nodes.end(); i++) {
        i->goAndZeroForce(timeStep, enviroment(i->pos.y));        //poruszam wêz³y i zeruje si³y
        terrain.correctPoint(i->pos);		//pilnuje by nie wylecia³y za plansze
    }
    train.go(timeStep, *this);        //porusza poci±giem
    for (std::list<Link*>::iterator i = bridge.begin(); i != bridge.end(); i++)
        train.satisfyLineConstraints(**i); //kolizja z belkami mostu
    train.satisfyTerrainConstraints(terrain); //kolizja z terenem
	train.satisfyConstraints();//Poprawia kszta³t wszystkich wagonów
	for (std::list<Node*>::iterator i = unactive_nodes.begin(); i != unactive_nodes.end(); i++)
		(*i)->pos = (*i)->pos_0; //pilnujemy ¿eby wêz³y uwi±zane mia³y sta³± pozycje
	for (std::list<Link>::iterator i = links.begin(); i != links.end();)
	  if (i->toLong()) {
	     bridge.remove(&(*i));
	     //unactive_links.push_back(*i); //TODO unactive_links
         i = links.erase(i);
         //TODO tu mo¿na by pozbyæ siê z niczym nie po³¹czonych wêz³ów
      } else ++i;         //usówa zerwane ³acza
}

void World::start() {
   	stop();
   	//obliczanie masy wêz³ów:
    for (std::list<Link>::iterator i = links.begin(); i != links.end(); i++) {
        i->A.mass += i->mass / 2.0;
        i->B.mass += i->mass / 2.0;
    }
}

void World::stop() {
    time = 0.0;
	//kopiujemy link do g³ównej listy
    clone_links_list();

    for (std::list<Node>::iterator i = nodes.begin(); i != nodes.end(); i++)
   	    i->reset();  //resetuje wêz³y

   	bridge.clear();
   	for (std::list<Link>::iterator i = links.begin(); i != links.end(); i++) {
   	    i->reset();
   	    if (i->A.pos.y == 0.0 && i->B.pos.y == 0.0) //belka stanowi most
   	            bridge.push_back(&*i);
    }
   	train.reset(); //resetuje pozycje poci¹gu
}

std::list<Node>::iterator World::findNode(const double left, const double top, const double right, const double bottom) {
    return std::find_if(nodes.begin(), nodes.end(), Node::InRect(left, top, right, bottom));
}

std::list<Node>::iterator World::findNode(const double x, const double y, const double prec) {
    return findNode(x-prec, y+prec, x+prec, y-prec);
}

std::list<Node>::iterator World::addNode(const Node& toAdd) {
    nodes.push_back(toAdd);
    if (terrain.touch(toAdd.pos)) {
        unactive_nodes.push_back(&nodes.back());
        nodes.back().movable = false;
    }
    return --nodes.end();
}

std::list<Link>::iterator World::addLink(const double x0, const double y0, const double x1, const double y1, const double prec) {
	if (fabs(x0 - x1) < prec && fabs(y0 - y1) < prec) return links_all.end();

	std::list<Node>::iterator first = findNode(x0, y0, prec);
    std::list<Node>::iterator second = findNode(x1, y1, prec);

    if (first != nodes.end() && second != nodes.end()) //jesli istnieje ju¿ link ³¹cz¹cy to wychodzimy
        for (std::list<Link>::iterator l = links.begin(); l != links.end(); l++)
            if (Link::IsEnd()(*l, *first) && Link::IsEnd()(*l, *second)) return l;

    if (first == nodes.end())  //dodaje wêze³ jeœli potrzebny
        first = addNode(Node(x0, y0, 500.0));

    if (second == nodes.end()) //dodaje wêze³ jeœli potrzebny
        second = addNode(Node(x1, y1, 500.0));

    if (first->pos.x > second->pos.x) //sortujemy po wspó³rzêdnej x
        links_all.push_back(Link(*second, *first));
    else
    	links_all.push_back(Link(*first, *second));//Dodaje nowe ³¹cze
    links.push_back(links_all.back());

    return --links_all.end();
};

bool World::addLinkIfHaveMonay(const double x0, const double y0, const double x1, const double y1, const double prec) {
	if (money_left() >= link_prize(x0, y0, x1, y1)) {
		addLink(x0, y0, x1, y1, prec);
		return true;
	} else
		return false;
}


void World::clone_links_list() {
	links.clear();
	std::copy(links_all.begin(), links_all.end(), std::back_inserter(links));
}

void World::delAt(const double x, const double y, const double prec) {
    std::list<Node>::iterator node = findNode(x, y, prec);
    if (node == nodes.end()) {   //nie klikniêto na wie¿cho³ek. TODO: poszukaæ i usun¹æ link
        return;
    }
    //usówamy wie¿cho³ek
    //najpierw wszystkie przyleg³e linki i ew. wie¿cho³ki stopnia 1
    for (std::list<Link>::iterator l = find_if(links_all.begin(), links_all.end(), std::bind2nd(Link::IsEnd(), *node));
         l != links_all.end(); l = find_if(l, links_all.end(), std::bind2nd(Link::IsEnd(), *node))) {
             Node& toDel = (l->A == *node ? l->B : l->A); //2gi koniec linka
             l = links_all.erase(l); //usówam link i przesówam wskaŸnik
             if (count_if(links_all.begin(), links_all.end(), std::bind2nd(Link::IsEnd(), toDel)) == 0) {
                  unactive_nodes.remove(&toDel);
                  nodes.remove(toDel);        //jest nieu¿ywany wiêc usówamy
             }
         }
    clone_links_list();
    unactive_nodes.remove(&*node);
    nodes.erase(node);
};

void World::clear() {
    bridge.clear();
    links_all.clear();
    //unactive_links.clear();//TODO unactive_links
    links.clear();
    unactive_nodes.clear();
    nodes.clear();
}

std::istream& operator>>(std::istream& in, World &w) {
	in >> w.money_limit;
    in >> w.terrain;
    double x0, y0, x1, y1;
    int len;
    in >> len;
    w.clear();
    for (int i = 0; i < len; i++) {
        in >> x0;
        in >> y0;
        in >> x1;
        in >> y1;
        w.addLink(x0, y0, x1, y1);
    }
    w.stop();
    return in;
}

std::ostream& operator<<(std::ostream& out, World &w) {
	out << w.money_limit << std::endl;
    out << w.terrain << std::endl << w.links.size() << std::endl;
    for (std::list<Link>::iterator i = w.links_all.begin(); i != w.links_all.end(); i++)
        out << ' ' << i->A.pos_0.x << ' ' << i->A.pos_0.y << ' '
                   << i->B.pos_0.x << ' ' << i->B.pos_0.y << std::endl;
    return out;
}

double World::link_prize(double len) {
	return len*len + 2.0*len;
}

double World::money_left() const {
	double sum = 0.0;
	for (std::list<Link>::const_iterator i = links_all.begin(); i != links_all.end(); ++i)
		sum += link_prize(i->length);
	return money_limit - sum;
}

bool World::is_level_complited() const {
	const double terrain_end = terrain.toX() + 10;	//10 meters after terrain end
	return
		train.wagons.back().leftDown.pos.x > terrain_end &&
		train.wagons.front().leftDown.pos.x > terrain_end;
}
